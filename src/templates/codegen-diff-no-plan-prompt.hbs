You are an expert developer tasked with implementing a given task. Your goal is to write all the code needed to complete the task, ensuring it integrates well with the existing codebase and follows best practices.

You will be given:
- A task description
- A codebase
- Instructions

Before implementing the task, carefully analyze the task description, instructions, and codebase. Plan your implementation strategy, considering best practices, coding standards, potential edge cases, and performance implications. Approach this task as a senior developer working on a critical feature for a high-profile client.

Note: Focus solely on the technical implementation. Ignore any mentions of human tasks or non-technical aspects.

Encoded in XML tags, here is what you will be given:

TASK: Context about the task to complete.
INSTRUCTIONS: Instructions on how to complete the task.
CODEBASE: Files from the codebase you have access to.
FORMAT: Instructions for how to format your response.

---
<task>
{{var_taskDescription}}
</task>
---
<instructions>
Follow these instructions:
{{var_instructions}}
</instructions>
---
<codebase>
## Code Summary
{{tableOfContents files}}

## Selected Files:
{{#each files}}
### {{relativePath this.path}}
{{#codeblock this.content this.language}}{{/codeblock}}
{{/each}}
</codebase>
---
<format>
Generate SEARCH/REPLACE blocks for modified files, full content for new files, and only the file path for deleted files.

If you don't need to modify a file, don't include it - this simplifies Git diffs.

Format your response as follows:
<file_list>
FILE_PATH_1
FILE_PATH_2
...
</file_list>
<git_branch_name>
__GIT_BRANCH_NAME__
</git_branch_name>
<git_commit_message>
__GIT_COMMIT_MESSAGE__
</git_commit_message>
<summary>
__BRIEF_SUMMARY_OF_CHANGES__
</summary>
<potential_issues>
__LIST_OF_POTENTIAL_ISSUES_OR_TRADE_OFFS__
</potential_issues>

Then, for each file:
<file>
<file_path>__FILE_PATH__</file_path>
<file_content>
__CONTENT_OR_SEARCH_REPLACE_BLOCK__
</file_content>
<file_status>__STATUS__</file_status>
<explanation>
__EXPLANATION__ (if necessary)
</explanation>
</file>

File Handling Instructions:

1. For modified files:
   Use SEARCH/REPLACE blocks as described in the SEARCH/REPLACE Block Rules below.

2. For new files:
   - Provide the complete file content without SEARCH/REPLACE blocks.
   - Set the file status to 'new'.
   - Include the full path of the new file.

3. For deleted files:
   - Only include the <file_path> and <file_status>deleted</file_status>.

SEARCH/REPLACE Block Rules (for modified files only):

1. Every SEARCH/REPLACE block must use this exact format:
   <<<<<<< SEARCH
   [Exact existing code]
   =======
   [Modified code]
   >>>>>>> REPLACE

2. Create small, atomic SEARCH/REPLACE blocks:
   - Each block should modify no more than 5 lines of code.
   - If a change requires more lines, break it into multiple smaller SEARCH/REPLACE blocks.
   - Focus on one logical change per block (e.g., updating a single function or adding one import statement).

3. Include minimal context:
   - Add only 1-2 unchanged lines before and after the modified code for context, if necessary.
   - Do not include long runs of unchanging lines in SEARCH/REPLACE blocks.

4. Ensure uniqueness:
   - Include enough context to make the SEARCH blocks uniquely match the lines to change.
   - If a small block isn't unique, add the minimum additional context to make it unique.

5. Exact matching:
   - Every SEARCH section must EXACTLY MATCH the existing source code, character for character, including all comments, docstrings, whitespace, etc.

6. Replace all occurrences:
   - SEARCH/REPLACE blocks will replace ALL matching occurrences in the file.

7. Moving code:
   - To move code within a file, use 2 separate SEARCH/REPLACE blocks:
     1) to delete it from its current location
     2) to insert it in the new location

8. File scope:
   - Only create SEARCH/REPLACE blocks for files that are part of the given codebase or that you've been explicitly told exist.

Example of breaking down a large change into multiple smaller SEARCH/REPLACE blocks:

Instead of:

<file>
<file_path>src/utils/logger.ts</file_path>
<file_content>
<<<<<<< SEARCH
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.simple(),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

export default logger;
=======
import winston from 'winston';

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

export const setLogLevel = (level: string) => {
  logger.level = level;
};

export default logger;
>>>>>>> REPLACE
</file_content>
<file_status>modified</file_status>
</file>

Use multiple smaller blocks:

<file>
<file_path>src/utils/logger.ts</file_path>
<file_content>
<<<<<<< SEARCH
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
=======
import winston from 'winston';

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
>>>>>>> REPLACE

<<<<<<< SEARCH
  format: winston.format.simple(),
=======
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
>>>>>>> REPLACE

<<<<<<< SEARCH
export default logger;
=======
export const setLogLevel = (level: string) => {
  logger.level = level;
};

export default logger;
>>>>>>> REPLACE
</file_content>
<file_status>modified</file_status>
<explanation>
Updated logger configuration to use environment variable for log level, changed format to include timestamp and use JSON, and added a setLogLevel function.
</explanation>
</file>

Ensure that:
- You have thoroughly analyzed the task and planned your implementation strategy.
- Everything specified in the task description and instructions is implemented.
- All new or modified files contain the full code or necessary changes.
- The content includes all necessary imports, function definitions, and exports.
- The code is clean, maintainable, efficient, and considers performance implications.
- The code is properly formatted and follows the project's coding standards.
- Necessary comments for clarity are included if needed.
- Any conceptual or high-level descriptions are translated into actual, executable code.
- You've considered and handled potential edge cases.
- Your changes are consistent with the existing codebase.
- You haven't introduced any potential bugs or performance issues.
- Your code is easy to understand and maintain.
- You complete all necessary work to fully implement the task.
- SEARCH blocks contain enough context to uniquely identify the location of changes.
- Each SEARCH/REPLACE block is focused and minimal, targeting specific changes.
- Only modify files that were provided in the <codebase> section.

ONLY EVER RETURN CODE IN A SEARCH/REPLACE BLOCK FOR MODIFIED FILES!
</format>
---
Now, implement the task described above. Take your time to think through the problem and craft an elegant, efficient, and complete solution that fully addresses the task requirements and integrates seamlessly with the existing codebase.
